# longy Development Log

## v0.4 — Completed 2026-02-18

### What was built

**Part 1: g_R in TMLE clever covariate**
- TMLE now uses `H(s) = 1 / (g_cum(s) * g_r(s))` instead of `H(s) = 1 / g_cum(s)`
- `.compute_cumulative_g()` returns `.g_r` column (point-in-time observation probability)
- `longy()` now fits g_R for TMLE (not just IPW) — moved to shared nuisance section
- `.tmle_fluctuate()` and `.compute_tmle_eif()` use `g_cum * g_r` denominator

**Part 2: Cross-fitting (CV-TMLE)**
- `longy(..., cross_fit = 5, cross_fit_seed = 42)` enables 5-fold cross-fitting
- Dispatch at `fit_*` level: when `obj$crossfit$enabled`, calls `.cf_fit_*()` variants
- `.cf_fit_treatment()`, `.cf_fit_censoring()`, `.cf_fit_observation()` in `crossfit.R`
  - Each time point: split risk set by fold, fit on train, predict on validation
  - Marginal rates from FULL risk set (population constants)
- `.cf_estimate_tmle()` — CV-TMLE with pooled fluctuation (Zheng & van der Laan 2011)
  - Q models cross-fitted within backward pass via `.cf_fit_q_step()`
  - Single epsilon per step (safe: scalar, no overfitting)
  - EIF computed with cross-fitted Q* and cross-fitted g
- `.predict_from_fit()` helper in `utils.R` — predict from `.safe_sl()` fit on new data
- `.remove_tracking_columns()` preserves `.longy_fold` across fit_* calls
- `data.table::set()` for Q propagation to avoid reference-copy issues

### Files changed

| File | Changes |
|------|---------|
| `R/crossfit.R` | Replaced stub with 6 functions (~470 lines) |
| `R/weights.R` | `.compute_cumulative_g()` returns `.g_r` |
| `R/estimate_tmle.R` | CF dispatch; g_R in fluctuation + EIF |
| `R/longy.R` | `cross_fit`/`cross_fit_seed` params; g_R shared |
| `R/fit_treatment.R` | CF dispatch; `.remove_tracking_columns()` preserves fold |
| `R/fit_censoring.R` | CF dispatch |
| `R/fit_observation.R` | CF dispatch |
| `R/utils.R` | `.predict_from_fit()` |
| `R/longy-package.R` | Added `.g_r` and survival globals |

### Test status
- 307 tests passing, 0 errors/warnings/notes in R CMD check
- Smoke tested: binary, continuous, survival outcomes with cross_fit = 5
- estimator = "all" with cross-fitting works correctly

---

## v0.1 — Completed 2026-02-12

### What was built

Full R package implementing IPW estimation for longitudinal causal inference. The package is installed at `longy/` and pushed to `github.com/joshua-nugent/longy` (private).

### Package contents

**14 R source files:**

| File | What it does |
|------|-------------|
| `R/longy.R` | `longy()` high-level wrapper — runs full pipeline in one call |
| `R/data_input.R` | `longy_data()` constructor, validation, `set_crossfit()`, print/summary |
| `R/regimes.R` | `define_regime()` for static/dynamic/stochastic regimes |
| `R/fit_treatment.R` | `fit_treatment()` — g_A propensity score models |
| `R/fit_censoring.R` | `fit_censoring()` — g_C censoring models (absorbing, cumulated) |
| `R/fit_observation.R` | `fit_observation()` — g_R observation models (intermittent, NOT cumulated) |
| `R/weights.R` | `compute_weights()` — combines all nuisance models into final IPW weights |
| `R/estimate_ipw.R` | `estimate_ipw()` — Hajek estimator, print/summary/plot methods |
| `R/inference.R` | IC-based, bootstrap, and sandwich (survey pkg) inference |
| `R/diagnostics.R` | `weight_diagnostics()`, `positivity_diagnostics()` |
| `R/crossfit.R` | Stub — architecture ready, implementation deferred to v0.3 |
| `R/utils.R` | `.bound()`, `.safe_sl()`, `.adaptive_cv_folds()`, `.ess()`, etc. |
| `R/longy-package.R` | Package-level docs, sim_longy dataset docs, globalVariables |
| `R/zzz.R` | .onLoad |

**Simulated dataset:** `data/sim_longy.rda` — 2000 subjects, 10 time points, with known true causal effects stored as attribute `"true_effects"`. Generated by `data-raw/make_sim_longy.R`.

**Tests:** 146 tests across 10 test files in `tests/testthat/`, plus `helper-simulate.R` with 6 data generators (`simulate_test_data`, `simulate_no_confounding`, `simulate_no_censoring`, `simulate_always_observed`, `simulate_continuous_outcome`, `simulate_survival_outcome`).

**Docs:** All exported functions have roxygen2 documentation. 15 `.Rd` files in `man/`.

### Key design decisions

- **S3 classes** (not R6) for `longy_data`, `longy_result`, `longy_results`
- **data.table** internally via `@import data.table`; accepts data.frame at boundary
- **SuperLearner** optional (in Suggests); falls back to glm via `.safe_sl()`
- **Long format only** — one row per person-time
- **Three nuisance models** matching `ipw run.R`:
  - g_A: treatment propensity (risk set: consistent + uncensored through t-1)
  - g_C: censoring (risk set: above + treatment at t consistent with regime)
  - g_R: observation (risk set: above + uncensored at t — most restrictive)
- **Weight formula**: `final(t) = cumprod(sw_a * sw_c)[t] * sw_r(t)` — A×C cumulated, R point-in-time
- **Pipe-friendly**: each step returns modified `longy_data` object

### Verification results

- `devtools::check()`: **0 errors, 0 warnings**, 1 note (global variable binding — cosmetic)
- `devtools::test()`: **146/146 pass**
- End-to-end on `sim_longy`: runs both regimes, early time points track known truth

### Issues encountered and resolved

1. **data.table cedta() error in R CMD check**: Fixed by using `@import data.table` instead of individual `@importFrom`, and replacing `.()` with `list()` in data.table `[` calls.
2. **Non-ASCII characters**: Em-dashes in `estimate_ipw.R` caused WARNING. Replaced with `--`.
3. **Marginal fallback not bounded**: When all outcomes at a time point are the same value, the marginal mean (0 or 1) exceeded prediction bounds. Fixed by applying `.bound()` to marginal fallback too.
4. **IC SE = 0 when all outcomes identical**: Legitimate edge case. Test updated to allow SE=0 when estimate is 0 or 1.
5. **IC variance fix**: Centered IC (using `stats::var()`) for finite-sample robustness, following ltmle's HouseholdIC pattern.
6. **Sampling weights**: Added external sampling/survey weights support throughout pipeline (nuisance model fitting, marginal rates, final weight multiplication).
7. **Continuous outcome support**: Verified Hajek estimator + IC inference work unchanged for continuous Y. Added binary outcome validation (`Y in {0,1,NA}` when `outcome_type = "binary"`).
8. **Survival outcome + isotonic smoothing**: Added `stats::isoreg()` post-processing for survival outcomes to enforce monotone non-decreasing cumulative incidence. SEs from unsmoothed ICs, CIs recomputed around smoothed estimates.
9. **Better error messages**: Defensive `tryCatch` on dynamic/stochastic regime evaluation, always-warn on SuperLearner failure, GLM fallback tryCatch, non-finite weight warnings, empty-fits warnings, consistent "Use define_regime() first" messages, survey install suggestion.
10. **Plot method**: `plot.longy_result()` with ggplot2 (optional) or base R fallback.

### Reference materials

- `ipw run.R` — the working IPW script this package is based on (in parent dir)
- `ltmle-master/` — ltmle package source (in parent dir)
- `stremr-master/` — stremr package source (in parent dir)
- `ffSL.R` — parallel SuperLearner wrapper used by ipw run.R (in parent dir)

---

## Next steps

### Short-term improvements to v0.1 (all complete)

1. ~~**Larger simulated dataset**~~ -- Done (n=2000).
2. ~~**SuperLearner integration testing**~~ -- Done (explicit SL test added).
3. ~~**Sandwich inference testing**~~ -- Done (explicit test + IC/sandwich agreement test).
4. ~~**Continuous outcome support**~~ -- Done. Hajek estimator works unchanged; added binary outcome validation and end-to-end continuous tests.
5. ~~**Survival outcome support**~~ -- Done. Added isotonic smoothing via `stats::isoreg()` for monotone cumulative incidence.
6. ~~**Better error messages**~~ -- Done. Defensive tryCatch on regimes, SL/GLM failures, non-finite weights, empty fits, consistent messages.

### v0.2 — G-computation (Completed 2026-02-13)

**What was built:** G-computation estimator using direct outcome regression at each time point. This gives a second estimator that relies on correct outcome model specification instead of correct propensity score specification.

**New files:**
| File | What it does |
|------|-------------|
| `R/fit_outcome.R` | `fit_outcome()` — outcome model E[Y_t \| covariates, A] at each time |
| `R/estimate_gcomp.R` | `estimate_gcomp()` — G-comp point estimates + bootstrap inference |

**Modified files:**
| File | Changes |
|------|---------|
| `R/longy.R` | Added `estimator` param (`"ipw"`, `"gcomp"`, `"both"`); `n_boot=0` skips all inference |
| `R/inference.R` | Added `.bootstrap_gcomp_inference()`, `.run_bootstrap()` with `future.apply` parallel support |
| `R/estimate_ipw.R` | Updated print/summary/plot methods to handle G-comp label; `inference="none"` option |
| `R/longy-package.R` | Added new globalVariables for fit_outcome columns |
| `DESCRIPTION` | Added `future`, `future.apply` to Suggests |

**Algorithm:**
1. At each time t (backward loop, though order doesn't matter):
   - Risk set: ALL uncensored subjects through t (not regime-restricted)
   - Training subset: risk set AND Y_t non-missing (handles R=0 intermittent missingness)
   - Fit Y_t ~ baseline + timevarying + A using `.safe_sl()`
   - Predict counterfactually (set A to regime value) for all in risk set
2. Point estimate: mean(Q_hat(t)) at each requested time = E[Y_t(a)]
3. Inference: nonparametric bootstrap (resample subjects, refit, percentile CIs)
4. Isotonic smoothing for survival outcomes (same as IPW)

**Key design decisions:**
- **A included in covariates** — model learns E[Y | X, A], counterfactual prediction sets A = regime value
- **Broad risk set** — all uncensored subjects, not just regime-consistent. Lets model learn from treatment variation; counterfactual predictions handle the intervention
- **No backward pseudo-outcome propagation** — each time t fits Y_t directly. L_t mediates past treatment effects, so a correctly specified concurrent model gives E[Y_t(a)]. Backward ICE will be re-introduced for TMLE targeting
- **Known limitation**: without censoring adjustment, G-comp targets E[Y_t(a) | uncensored through t], not E[Y_t(a)] in the full population. TMLE/IPCW will address this
- Bootstrap-only inference for pure G-comp (no EIF/IC formula). DR-IC arrives with TMLE in v0.3
- No propensity models required — G-comp point estimates don't need g_A/g_C/g_R
- `estimator = "both"` appends `_ipw` / `_gcomp` suffixes to regime names
- Parallel bootstrap via `future.apply` when a non-sequential `future::plan()` is active

**Verification:**
- `devtools::check()`: **0 errors, 0 warnings, 0 notes**
- `devtools::test()`: **196/196 pass** (146 existing + 50 new G-comp tests)
- Truth-recovery test: continuous outcome G-comp matches E[Y_t(a)] = 0.3a + 0.05t within 0.05 at each time (no-censoring DGP)
- Binary, continuous, survival outcomes all work end-to-end
- Monotone cumulative incidence enforced for survival via isotonic smoothing
- `longy(estimator = "gcomp")` and `longy(estimator = "both")` work end-to-end
- Parallel bootstrap tested with `future::multisession`

### v0.3 — TMLE (Completed 2026-02-13)

**What was built:** Doubly-robust TMLE estimator. Combines outcome regression (backward ICE) with a targeting/fluctuation step using treatment/censoring model predictions. Consistent if either Q models OR g models are correct. Inference via efficient influence function (EIF).

**New files:**
| File | What it does |
|------|-------------|
| `R/estimate_tmle.R` | `estimate_tmle()`, `.tmle_fluctuate()`, `.compute_tmle_eif()` |

**Modified files:**
| File | Changes |
|------|---------|
| `R/weights.R` | Added `.compute_cumulative_g()` shared helper; `g_bounds` param to `compute_weights()` |
| `R/longy.R` | Added `estimator = "tmle"`, `g_bounds`, `outcome_range` params; TMLE pipeline |
| `R/inference.R` | Added `.bootstrap_tmle_inference()` |
| `R/estimate_ipw.R` | Updated print/summary/plot methods to handle TMLE label |
| `R/longy-package.R` | Added new globalVariables for TMLE/cumulative g columns |

**Algorithm (per target time T):**
1. Scale continuous Y to [0,1]; all types use quasibinomial fluctuation
2. Compute g_cum(s) = cumprod(g_a * g_c) per subject (`.compute_cumulative_g()`)
3. Backward from T to min(time), at each step s:
   a. Fit Q model (quasibinomial) on risk set with non-NA Q
   b. Predict counterfactually (A = regime) for all risk set -> Q_bar
   c. Fluctuate: quasibinomial GLM, offset = logit(Q_bar), weights = 1/g_cum
   d. Q* = expit(logit(Q_bar) + epsilon) for ALL risk set
   e. Propagate Q* backward as pseudo-outcome (TARGETED, not raw G-comp)
4. psi_hat = mean(Q*_0), back-transformed if continuous
5. EIF: D_i = (Q*_0 - psi) + sum_s H_s * (Q*_{s+1} - Q*_s)
   where H_s = I(regime-consistent, uncensored) / g_cum(s)

**Key design decisions:**
- **Interleaved Q fitting + targeting**: TMLE runs its own backward pass (cannot reuse fit_outcome predictions). Q at step s trains on TARGETED pseudo-outcomes from s+1
- **Reads outcome model settings**: estimate_tmle reads covariates, learners, bounds from obj$fits$outcome to avoid parameter duplication. Requires fit_outcome() to have been run first
- **quasibinomial for everything**: Continuous Y scaled to [0,1]; pseudo-outcomes are fractional. quasibinomial handles all cases correctly (same as ltmle/stremr)
- **Shared `.compute_cumulative_g()`**: Used by both compute_weights (IPW) and estimate_tmle (TMLE). Computes unstabilized cumulative g with g_bounds
- **No g_R in clever covariate**: Following ltmle, observation model not in TMLE clever covariate. Q conditions on R=1 implicitly. TMLE targets E[Y_T(a)|always observed]
- **EIF inference by default**: For TMLE, `n_boot=0` gives EIF-based SEs (cheap). Bootstrap available for explicit request
- **g_bounds shared**: c(0.01, 1) default, bounds cumulative g denominator in both IPW weights and TMLE clever covariate
- Cross-fitting deferred to follow-up (touches all fit_* functions)

**Verification:**
- `devtools::check()`: **0 errors, 0 warnings, 0 notes**
- `devtools::test()`: **270/270 pass** (204 existing + 66 new TMLE tests)
- Binary, continuous, survival outcomes all work end-to-end
- EIF-based SEs positive, CIs well-formed and contain point estimates
- TMLE close to G-comp under well-specified models
- No-confounding truth recovery within tolerance
- `longy(estimator = "tmle")` works end-to-end for all outcome types
- Print method outputs "TMLE", `.compute_cumulative_g()` returns valid non-increasing g_cum

**Design note — G-comp censoring adjustment (2026-02-13):**
Current G-comp targets E[Y_t(a) | uncensored through t], not E[Y_t(a)] in the full population, because it fits only on uncensored subjects without IPCW weighting. Two approaches were considered:
- **(a) IPCW-weighted outcome regression** (stremr approach): weight the outcome model by cumulative inverse censoring probability. Makes standalone G-comp correct under informative censoring but requires g_C models, breaking the "no propensity needed" simplicity.
- **(b) Let TMLE handle it** (lmtp approach): leave G-comp as restriction-only; the TMLE fluctuation step corrects for censoring bias via the clever covariate.
Decision: go with (b) for now. Revisit adding optional IPCW weights to `fit_outcome()` later if users need a censoring-adjusted G-comp without full TMLE.

### v0.4 — Cross-fitting

- Activate cross-fitting in `crossfit.R` -- sample-split nuisance estimation
- `set_crossfit()` already assigns folds; need to loop fits over folds
- Touches all `fit_*` functions + estimate_tmle

### v0.5+ — Extensions

- Stochastic interventions (regime infrastructure already supports this)
- Continuous treatments
- Competing risks
- Marginal structural models (smoothing across time)
- Optional IPCW-weighted G-comp (revisit from v0.3 design note)
- ffSL-style parallel SuperLearner (port from user's `ffSL.R`)

### Code quality

- Add `pkgdown` site
- Add CI via GitHub Actions (`R-CMD-check.yaml`)
- Consider `lintr` / `styler` for consistent formatting
- Vignette: "Getting started with longy"
